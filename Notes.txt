- Как прогнозировать критическое сближение?
	1. Рассчитать местоположение всех (или ближайших ВС) через нужный интервал (у нас 45 с);
	2. По т. Пифагора найти расстояния от точки БПЛА до точки конфликта;
	3. Если растояние обнаруживается конфликт => БПЛА делает манёвр;

- Как можно различать точки в одном списке?
	1. У каждой точки завести Id, уникальный для каждой группы точек;
	2. Хранить их в листе по индексу = Id;

- Когда и где инициализируем Points?
	При кофигурации fieldControl инициализируем Field и в Field инициализируем Points.

- Сборка трассы:
	1. 

- Как составлять трассу при любом количестве точек?
	0. У каждой точки есть Id;
	1. Делим все точки на несколько групп: точки старта, точки финиша и промежуточные;
	2. Если промежуточные точки легко и понятно делятся на подгруппы, которые можно упорядочить, то их тоже разделить;
	3. Каждая группа - словарь, где ключ = id точки, значение = точка;
	4. Все получившиеся группы (старт, финиш и остальные) собираем в лист в строгом порядке: старт - промежуточные (если > 1 - тоже выстраиваются в цепочку) - финиш;
	5. Трасса - это последовательность индексов, где каждый следующий индекс - индекс точки в следующем листе;
	6. При этом, если промежуточные точки никак не упорядочиваются, это не мешает работе, так как мы просто обращаемся к точке по её id.
	7. Так делаем для каждого типа ВС;

- Где ставим таймеры?
	1. Два таймера для самолётов и БПЛА в Field;
	2. Графический таймер в модели;

- Что делаем по таймерам?
	1. По графическому (тик = 1 с):
		1. Вызываем CheckToChangePath();
		2. Обновляем смещения ВС (вызываем UpdateShifts());
		3. Проверяем и, если нужно, удаляем ВС по индексам (собираем список индексов для удаления по флагам);
		3. Обновляем отрисовку;
	2. По самолётному (тик 90 - 240 с):
		1. Создаём самолёт (field.AddAircraft());
	3. По беспилотному (тик = 90 - 240 с):
		1. Создаём БПЛА (field.AddAircraft());


- Задачи:
	1. Смещения; +
	2. Таймеры; +
	3. Время и его отображение; +
	4. Отрисовка на каждом контроле; +
	5. Расширения для графики; +
	6. Создание маршрута; +
	7. Добавление/удаление ВС; +
	8. Обработчики событий таймеров; +
	9. Кнопки и обработка нажатий; +
	10. Отрисовка точек; + 
	11. Отрисовка движения ВС; +
	12. Отрисовка траекторий; +
	13. Отрисовка формуляров; +
	14. Отрисовка сетки; +
	15. Проблема с координатами точек; +
	16. Удаление всех ВС по нажатию на Stop; +
	17. Перерисовка всех ВС при изменении размера; + 
	18. Отображение формуляров; + 
	19. Настройка интервалов таймеров ВС на разные значения, а не на псевдослучайные числа; +
	20. Прогнозирование столкновений; +
	21. Уход с линии; +
	22. Провести первый рефакторинг;

- Рефакторинг:
	1. Сделать программу модульной (помогут грамотно составленные интерфейсы);
	2. Ограничить доступ к основным данным для минимизации влияния изменений в них;
	3. Разбить большие классы на мелкие;
	4. Отделить и скрыть сложные элементы реализации;
	5. Уменьшить сопряжение классов и методов;
	6. 

- Проблемы:
	1. Ошибка при сворачивании окна;
	2. При изменении размера окна, видимо, как-то неправильно пересчитывается местоположение ВС, и, в итоге показания высоты сбиваются;
	3. Поменять конфликтные точки на втором маршруте; +
	4. Не давать изменять смещение по Z при Resize;
	5. Исправить микро смещение будущей точки ВС;
	6. Завести отдельный таймер для каждого потока;

- Заметки:
	- Расстояние между садящимися самолётами обычно 8 - 10 км;

- Идеи:
	- Продолжай делить и упрощать модули до тех пор, пока закодировать модуль не станет проще, чем разделить его, когда простота модулю не станет очевидной
	- Аргумент в пользу метода абсолютного набора высоты: при исчезновении опасности столкновения в одним самолётом, через некоторое время может появится другой самолёт, 
	для ухода от которого времени уже не хватит, так как он окажется слишком близко.
	- Нумерация точек:
		- Предварительно разбить все точки на группы. Проходя по каждой группе присваивать порядковый номер.
	- Нужно упорядочить прилетающие и вылетающие потоки самолётов. Добавить перечисление. Изменить структуру хранения самолётов.